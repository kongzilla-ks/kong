// SECURITY ANALYSIS: Potential Double Payout Vulnerability in SOL to ICP Swaps
//
// SUMMARY:
// Kong's swap mechanism has a critical vulnerability where the same Solana transaction 
// signature can potentially be used multiple times to claim ICP tokens.
//
// VULNERABILITY DETAILS:
// 
// 1. The `transfer_map::contain()` function only checks for duplicate BlockIndex (IC tokens):
//    ```rust
//    pub fn contain(token_id: u32, block_id: &Nat) -> bool {
//        TRANSFER_MAP.with(|m| {
//            m.borrow()
//                .iter()
//                .any(|(_, v)| v.token_id == token_id && v.tx_id == TxId::BlockIndex(block_id.clone()))
//        })
//    }
//    ```
//    This function DOES NOT check for TxId::TransactionId (Solana signatures).
//
// 2. In swap_transfer.rs, when processing Solana payments:
//    - The system verifies the Solana transaction signature
//    - It creates a transfer record with TxId::TransactionId(tx_signature)
//    - BUT it does NOT check if this signature has already been used
//
// 3. The flow for Solana swaps:
//    a) User sends SOL to Kong's Solana address
//    b) kong_rpc detects the transaction and stores it
//    c) User calls swap_transfer with the transaction signature
//    d) Kong verifies the signature and transaction details
//    e) Kong sends ICP to the user
//    f) User can potentially call swap_transfer AGAIN with the same signature
//
// PROOF OF CONCEPT:
// ```rust
// // Step 1: User sends 1 SOL to Kong's address
// // Transaction signature: "abc123..."
// 
// // Step 2: First swap request
// let args1 = SwapArgs {
//     pay_token: "SOL".to_string(),
//     pay_amount: Nat::from(1_000_000_000u64), // 1 SOL
//     receive_token: "ICP".to_string(),
//     pay_tx_id: Some(TxId::TransactionId("abc123...".to_string())),
//     signature: Some("valid_signature_1".to_string()),
//     timestamp: Some(current_time()),
//     // ... other fields
// };
// let result1 = swap_transfer(args1).await; // SUCCESS - receives ICP
// 
// // Step 3: Second swap request with SAME transaction
// let args2 = SwapArgs {
//     pay_token: "SOL".to_string(), 
//     pay_amount: Nat::from(1_000_000_000u64), // 1 SOL
//     receive_token: "ICP".to_string(),
//     pay_tx_id: Some(TxId::TransactionId("abc123...".to_string())), // SAME TX!
//     signature: Some("valid_signature_2".to_string()), // Different signature
//     timestamp: Some(current_time()),
//     // ... other fields
// };
// let result2 = swap_transfer(args2).await; // POTENTIAL SUCCESS - double payout!
// ```
//
// WHY THIS WORKS:
// - The signature verification checks that the message is signed by the sender
// - The transaction verification confirms the SOL was sent
// - BUT nothing prevents reusing the same SOL transaction signature
// - Each request gets a new request_id, so they're treated as separate swaps
//
// RECOMMENDED FIX:
// 1. Add a new function to check for duplicate TransactionId:
//    ```rust
//    pub fn contain_transaction_id(token_id: u32, tx_signature: &str) -> bool {
//        TRANSFER_MAP.with(|m| {
//            m.borrow()
//                .iter()
//                .any(|(_, v)| v.token_id == token_id && 
//                     matches!(&v.tx_id, TxId::TransactionId(sig) if sig == tx_signature))
//        })
//    }
//    ```
//
// 2. Update swap_transfer.rs to check for duplicate Solana signatures:
//    ```rust
//    // Before creating the transfer record
//    if let TxId::TransactionId(ref sig) = tx_id {
//        if transfer_map::contain_transaction_id(token_id, sig) {
//            return Err("Transaction signature already used".to_string());
//        }
//    }
//    ```
//
// IMPACT:
// - HIGH SEVERITY: Attackers can drain Kong's ICP reserves
// - Each SOL transaction can be used multiple times to claim ICP
// - Only limited by timestamp freshness check (5 minutes)
//
// MITIGATING FACTORS:
// - Timestamp freshness check limits the window to 5 minutes
// - Requires valid signature (but can be different each time)
// - Transaction must exist in kong_rpc's storage