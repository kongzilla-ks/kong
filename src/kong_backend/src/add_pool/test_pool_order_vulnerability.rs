// Test script to demonstrate pool token order vulnerability

use candid::Nat;

// Key findings from code analysis:

// 1. NO TOKEN ORDER ENFORCEMENT in add_pool.rs
// - The code accepts token_0 and token_1 as provided by the user
// - No check that token_0.token_id < token_1.token_id
// - No sorting or reordering of tokens

// 2. POOL EXISTENCE CHECK in pool_map.rs (exists function, lines 148-155):
pub fn exists(token_0: &StableToken, token_1: &StableToken) -> bool {
    POOL_MAP.with(|m| {
        m.borrow().iter().any(|(_, v)| {
            // This checks BOTH orders - prevents duplicate pools
            v.token_id_0 == token_0.token_id() && v.token_id_1 == token_1.token_id()
                || v.token_id_0 == token_1.token_id() && v.token_id_1 == token_0.token_id()
        })
    })
}

// 3. LP TOKEN ADDRESS GENERATION in token.rs (lines 138-140):
pub fn address(token_0: &StableToken, token_1: &StableToken) -> String {
    // Uses token IDs in the order provided - NO SORTING!
    format!("{}_{}", token_0.token_id(), token_1.token_id())
}

// 4. GET_BY_TOKEN_IDS in pool_map.rs (lines 111-120):
pub fn get_by_token_ids(token_id_0: u32, token_id_1: u32) -> Option<StablePool> {
    POOL_MAP.with(|m| {
        m.borrow().iter().find_map(|(_, v)| {
            // Only finds pools with exact order match
            if v.token_id_0 == token_id_0 && v.token_id_1 == token_id_1 {
                return Some(v);
            }
            None
        })
    })
}

// VULNERABILITY SCENARIO:
// 1. User creates pool with ICP (token_id=1) as token_0 and USDC (token_id=2) as token_1
//    - Pool created with token_id_0=1, token_id_1=2
//    - LP token address: "1_2"
//    - pool_map::exists() will prevent both (1,2) and (2,1) pools

// 2. When swapping USDC->ICP, the code looks for pool with get_by_token_ids(2, 1)
//    - This returns None because the pool was stored as (1, 2)
//    - Swap fails with "Pool not found"

// The vulnerability is that:
// - Pool creation doesn't enforce token order
// - Pool lookup expects exact order match
// - LP token addresses depend on order
// - But exists() check prevents duplicate pools in reverse order

// This creates an inconsistency where pools can be created in any order,
// but lookups expect a specific order, leading to "Pool not found" errors
// for valid pools when tokens are provided in reverse order.